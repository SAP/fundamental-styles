var m=Object.defineProperty,p=Object.defineProperties;var b=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var h=Object.prototype.hasOwnProperty,v=Object.prototype.propertyIsEnumerable;var o=(r,e,t)=>e in r?m(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,a=(r,e)=>{for(var t in e||(e={}))h.call(e,t)&&o(r,t,e[t]);if(n)for(var t of n(e))v.call(e,t)&&o(r,t,e[t]);return r},s=(r,e)=>p(r,b(e));/* empty css             */const f=`<div class="fd-off-screen" aria-live="polite">
    This will be read, whenever this element changes.
</div>
<div class="fd-text">Text with aria-live is kept far left of the screen. so it will not be visible, but it will be read by screen reader.</div>
`;const w={title:"Dev/Off Screen",parameters:{description:"For aria-live to read any change in element, we need to place element but it should not be visible to user.\n            At the same time, it can not be made `visibility: hidden` or `display: none`, as screen reader will not be able to pick this element.\n            This component will make sure that element is not visible on screen but it can be read by screen reader.",tags:["a11y"]}},i=()=>f;i.parameters={docs:{description:{story:`For aria-live to read any change in element, we need to place element but it should not be visible to user.
`}}};var l,c,d;i.parameters=s(a({},i.parameters),{docs:s(a({},(l=i.parameters)==null?void 0:l.docs),{source:a({originalSource:"() => primaryExampleHtml"},(d=(c=i.parameters)==null?void 0:c.docs)==null?void 0:d.source)})});const x=["Primary"];export{i as Primary,x as __namedExportsOrder,w as default};
